# coding: utf-8

require 'spec_helper'

# This spec was generated by rspec-rails when you ran the scaffold generator.
# It demonstrates how one might use RSpec to specify the controller code that
# was generated by Rails when you ran the scaffold generator.
#
# It assumes that the implementation code is generated by the rails scaffold
# generator.  If you are using any extension libraries to generate different
# controller code, this generated spec may or may not pass.
#
# It only uses APIs available in rails and/or rspec-rails.  There are a number
# of tools you can use to make these specs even more expressive, but we're
# sticking to rails and rspec-rails APIs to keep things simple and stable.
#
# Compared to earlier versions of this generator, there is very limited use of
# stubs and message expectations in this spec.  Stubs are only used when there
# is no simpler way to get a handle on the object needed for the example.
# Message expectations are only used when there is no simpler way to specify
# that an instance is receiving a specific message.

RSpec.configure do |c|
  # c.filter = {wip:true}
end

describe Admin::NaturesController do
  include SpecControllerHelper

  let(:nat1) {mock_model(Nature)}
  let(:nat2) {mock_model(Nature)}
   

  def valid_attributes
    {"name"=>'petite', "period_id"=>@p.id.to_s}
  end

  before(:each) do
    minimal_instances
    @p.stub(:natures).and_return(@a = double(Arel))
    @o.stub(:income_books).and_return [1,2]
      @o.stub(:outcome_books).and_return [3,4]
  end

  describe "GET index"  do 


    it "assigns recettes et dépenses" do
      get :index, {:period_id=>@p.to_param}, valid_session
      assigns(:books).should == [1,2, 3, 4]
    end
  end

  

  describe "GET new"  do 
    it "assigns a new nature as @nature" do
      @o.stub(:income_books).and_return [@mb = mock_model(Book),2] 
      @o.stub(:outcome_books).and_return [3,4]
      @a.should_receive(:new).and_return(@mock_nat = mock_model(Nature).as_new_record)
      @mock_nat.should_receive('book_id=').with(@mb.id).and_return
      get :new,  {:period_id=>@p.to_param}, valid_session
      assigns(:nature).should be_a_new(Nature)
    end
  end

  describe "GET edit"  do
    it "assigns the requested bank_account as @bank_account" do
      @a.should_receive(:find).with(nat1.to_param).and_return nat1
      get :edit,  {:period_id=>@p.to_param, :id=>nat1.to_param}, valid_session
      assigns(:nature).should == nat1
    end
  end

  describe "POST create"  do
    describe "with valid params" do
      it "creates a new nature" do
          @a.should_receive(:new).with(valid_attributes).and_return(@n = mock_model(Nature).as_new_record)
          @n.stub(:save)
          post :create, {:period_id=>@p.to_param, :nature => valid_attributes}, valid_session
      end

      it "assigns a newly created nature as @nature" do
        @a.stub(:new).and_return(nat1)
        nat1.stub(:save).and_return(true)
        post :create, {:period_id=>@p.to_param, :nature => valid_attributes}, valid_session
        assigns(:nature).should == nat1
        
      end

      it "redirects to the created bank_account" do
        @a.stub(:new).and_return(nat1)
        nat1.stub(:save).and_return(true)
        post :create, {:period_id=>@p.to_param, :nature => valid_attributes}, valid_session
        response.should redirect_to(admin_organism_period_natures_url(@o, @p))
      end 
    end

    describe "with invalid params" do
      
      it "re-renders the 'new' template" do
        @a.stub(:new).and_return(nat1)
        nat1.stub(:save).and_return(false)
        post :create, {:period_id=>@p.to_param, :nature => valid_attributes}, valid_session
        response.should render_template("new")
      end
    end
  end

  describe "PUT update" do
    describe "with valid params" do
      it "updates the requested nature" do
        @a.should_receive(:find).with(nat1.to_param).and_return(nat1)
        nat1.should_receive(:update_attributes).with({'these' => 'params'}).and_return(true)
        put :update,{:period_id=>@p.id.to_s,  :id => nat1.id, :nature => {'these' => 'params'}}, valid_session
      end

      it "assigns the requested nature as @nature" do
        @a.stub(:find).with(nat1.to_param).and_return(nat1)
        nat1.stub(:update_attributes).and_return(true)
        put :update, {:period_id=>@p.to_param,  :id => nat1.id, :nature => valid_attributes}, valid_session
        assigns(:nature).should == nat1
      end

      it "redirects to the natures index" do
        @a.stub(:find).with(nat1.to_param).and_return(nat1)
        nat1.stub(:update_attributes).and_return(true)
        put :update, {:period_id=>@p.to_param,  :id => nat1.id, :nature => valid_attributes}, valid_session
        response.should redirect_to(admin_organism_period_natures_url(@o, @p))
      end
    end

    describe "with invalid params" do
      it "assigns the bank_account as @bank_account" do
        @a.stub(:find).with(nat1.to_param).and_return(nat1)
        nat1.stub(:update_attributes).and_return(false)
        put :update, {:period_id=>@p.to_param,  :id => nat1.id, :nature => valid_attributes}, valid_session
        assigns(:nature).should eq(nat1)
      end

      it "re-renders the 'edit' template" do
       @a.stub(:find).with(nat1.to_param).and_return(nat1)
        nat1.stub(:update_attributes).and_return(false)
        put :update, {:period_id=>@p.to_param,  :id => nat1.id, :nature => valid_attributes}, valid_session
        response.should render_template("edit")
      end
    end
  end

  describe "DELETE destroy"  do
    it "destroys the requested nature" do
       @a.should_receive(:find).with(nat1.to_param).and_return(nat1)
       nat1.should_receive(:destroy).and_return true
        delete :destroy, {:period_id=>@p.to_param,  :id => nat1.to_param}, valid_session

    end

    it "redirects to the natures list" do
     @a.stub(:find).with(nat1.to_param).and_return(nat1)
         delete :destroy, {:period_id=>@p.to_param,  :id => nat1.to_param}, valid_session
      response.should redirect_to(admin_organism_period_natures_url(@o, @p))
    end
  end

  describe 'POST REORDER' do
    it 'should look for nature and assing it' do
      Nature.should_receive(:find).with(nat1.to_param).and_return nat1
      nat1.stub(:move_higher)
      post :reorder, {organism_id:@o.to_param, :period_id=>@p.to_param, 
        id:nat1.to_param, :fromPosition=>'3', :toPosition=>'1', :format=>:js}, valid_session
      
      assigns[:nature].should == nat1
    end

    it 'reçoit move_higher le nombre de fois nécessaire' do
      Nature.stub(:find).with(nat1.to_param).and_return nat1
      nat1.should_receive(:move_higher).exactly(2).times
      post :reorder, {organism_id:@o.to_param, :period_id=>@p.to_param,
        id:nat1.to_param, :fromPosition=>'3', :toPosition=>'1', :format=>:js}, valid_session
     end

    it 'reçoit move_lower le nombre de fois nécessaire' do
      Nature.stub(:find).with(nat1.to_param).and_return nat1
      nat1.should_receive(:move_lower).exactly(2).times
      post :reorder, {organism_id:@o.to_param, :period_id=>@p.to_param,
        id:nat1.to_param, :fromPosition=>'1', :toPosition=>'3', :format=>:js}, valid_session
     end

    it 'renvoie bad_request si mauvais argument' , wip:true do
      post :reorder, {organism_id:@o.to_param, :period_id=>@p.to_param,
        id:nat1.to_param, :fromPosition=>'1', :format=>:js}, valid_session
      response.code.to_s.should match /^4/ # renvoie une erreur de type 400
    end

  end

  

  
end
