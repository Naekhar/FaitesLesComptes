# -*- encoding : utf-8 -*-

require 'spec_helper'

# This spec was generated by rspec-rails when you ran the scaffold generator.
# It demonstrates how one might use RSpec to specify the controller code that
# was generated by Rails when you ran the scaffold generator.
#
# It assumes that the implementation code is generated by the rails scaffold
# generator.  If you are using any extension libraries to generate different
# controller code, this generated spec may or may not pass.
#
# It only uses APIs available in rails and/or rspec-rails.  There are a number
# of tools you can use to make these specs even more expressive, but we're
# sticking to rails and rspec-rails APIs to keep things simple and stable.
#
# Compared to earlier versions of this generator, there is very limited use of
# stubs and message expectations in this spec.  Stubs are only used when there
# is no simpler way to get a handle on the object needed for the example.
# Message expectations are only used when there is no simpler way to specify
# that an instance is receiving a specific message.

describe Admin::AccountsController do
  include SpecControllerHelper

  let(:a1) {mock_model(Account)}

  
  def valid_attributes
    {"name"=>'CrediX', "number"=>'5555', "period_id"=>@p.to_param}
  end

  before(:each) do
    minimal_instances
    @p.stub(:accounts).and_return @a = double(Arel)

  end

  describe "GET index" do


    it "assigns all accounts as @accounts" do
      @a.stub(:all).and_return [1,2] 
      get :index, {:period_id=>@p.to_param}, valid_session
      assigns(:accounts).should == [1,2]
    end
  end

  

  describe "GET new" do
    it "assigns a new account as @account" do
      @a.should_receive(:new).and_return mock_model(Account).as_new_record
      get :new,  {:period_id=>@p.to_param}, valid_session
      assigns(:account).should be_a_new(Account)
    end
  end

  describe "GET edit" do 
    it "assigns the requested account as @account" do
      Account.stub(:find).with(a1.to_param).and_return(a1)
      get :edit,{ period_id:@p.to_param, :id => a1.to_param}, valid_session
      assigns(:account).should == a1
    end
  end

  describe "POST create" do
    context 'with valid nomenclature' do
    before(:each) do
      @o.stub(:nomenclature).and_return(mock_model(Nomenclature, 'valid?'=>true))
    end

    describe "with valid params" do
      it "creates a new account" do
        @a.should_receive(:new).with(valid_attributes).and_return(@b = mock_model(Account).as_new_record)
        @b.stub(:save)
        post :create, {:period_id=>@p.to_param, :account => valid_attributes}, valid_session
      end

      it "assigns a newly created account as @account" do
        @a.stub(:new).and_return(a1)
        a1.stub(:save).and_return(true)
        post :create, {:period_id=>@p.to_param, :account => valid_attributes}, valid_session
        assigns(:account).should == a1
        
      end

      it "redirects to the created account" do
        @a.stub(:new).and_return(a1)
        a1.stub(:save).and_return(true)
        post :create, {:period_id=>@p.to_param, :account => valid_attributes}, valid_session
        response.should redirect_to(admin_period_accounts_url(@p))
      end 
    end

    describe "with invalid params" do
      
      it "re-renders the 'new' template" do
        @a.stub(:new).and_return(a1)
        a1.stub(:save).and_return(false)
        post :create, {:period_id=>@p.to_param, :account => valid_attributes}, valid_session
        response.should render_template("new")
      end
    end

    end

    context 'with invalid nomenclature' do
      before(:each) do
      @o.stub(:nomenclature).and_return(mock_model(Nomenclature, 'valid?'=>false, collect_errors:'liste des erreurs'))
      @a.stub(:new).and_return(a1)
        a1.stub(:save).and_return(true)
      post :create, {:period_id=>@p.to_param, :account => valid_attributes}, valid_session
    end
    it 'affiche un flash alert' do
      flash[:alert].should == 'liste des erreurs'
    end
    end
  end

  describe "PUT update" do
    context 'toutes les natures ont reliées' do
      before(:each) do
        @p.stub(:all_natures_linked_to_account?).and_return true
      end


      describe "with valid params" do


        it "updates the requested account" do
          Account.should_receive(:find).with(a1.to_param).and_return(a1)
          a1.should_receive(:update_attributes).with({'these' => 'params'}).and_return(true)
          put :update,{:period_id=>@p.to_param,  :id => a1.to_param, :account => {'these' => 'params'}}, valid_session
        end

        it "assigns the requested account as @account" do
          Account.stub(:find).with(a1.to_param).and_return(a1)
          a1.stub(:update_attributes).and_return(true)
          put :update,{:period_id=>@p.to_param,  :id => a1.to_param, :account => {'these' => 'params'}}, valid_session
          assigns(:account).should eq(a1)
        end

        it "redirects to the account" do
          Account.stub(:find).with(a1.to_param).and_return(a1)
          a1.stub(:update_attributes).and_return(true)
          put :update,{:period_id=>@p.to_param,  :id => a1.to_param, :account => {'these' => 'params'}}, valid_session
          response.should redirect_to(admin_period_accounts_url(@p))
        end
      end

      describe "with invalid params" do
        it "assigns the account as @account" do
          Account.stub(:find).with(a1.to_param).and_return(a1)
          a1.stub(:update_attributes).and_return(false)
          put :update,{:period_id=>@p.to_param,  :id => a1.to_param, :account => {'these' => 'params'}}, valid_session
          assigns(:account).should eq(a1)
        end

        it "re-renders the 'edit' template" do
          Account.stub(:find).with(a1.to_param).and_return(a1)
          a1.stub(:update_attributes).and_return(false)
          put :update,{:period_id=>@p.to_param,  :id => a1.to_param, :account => {'these' => 'params'}}, valid_session
          response.should render_template("edit")
        end
      end
    end

    context 'toutes les natures ne sont pas reliées' do
      before(:each) do
        @p.stub(:all_natures_linked_to_account?).and_return false
        @p.stub_chain(:array_natures_not_linked, :first, :income_outcome).and_return true
         Account.stub(:find).with(a1.to_param).and_return(a1)
          a1.stub(:update_attributes).and_return(true)
          put :update,{:period_id=>@p.to_param,  :id => a1.to_param, :account => {'these' => 'params'}}, valid_session
      end

      it 'renvoie vers le mapping' do
        response.should redirect_to(mapping_admin_period_accounts_url(@p, type:'incomes'))
      end

      it 'remplit un flash' do
        flash[:alert].should == 'Toutes les natures ne sont pas reliées à des comptes'
      end
    end
  end

  describe "GET mapping" do
    it 'cherche toutes les comptes non liés' do
      @p.should_receive(:accounts).and_return [a1]
      @p.stub_chain(:natures, :without_account).and_return ['n1', 'n2']
      get :mapping, {:period_id=>@p.to_param}, valid_session
      assigns(:accounts).should == [a1]
      assigns(:unlinked_natures).should == ['n1', 'n2']
    end
  end

  describe "DELETE destroy" do
    it "destroys the requested account" do
      Account.should_receive(:find).with(a1.to_param).and_return(a1)
      delete :destroy, {:period_id=>@p.to_param,  :id => a1.to_param}, valid_session

    end

    it "redirects to the accounts list" do
      Account.should_receive(:find).with(a1.id.to_s).and_return(a1)
      delete :destroy, {:period_id=>@p.to_param,  :id => a1.id.to_s}, valid_session
      response.should redirect_to(admin_period_accounts_url(@p))
    end
  end

end
