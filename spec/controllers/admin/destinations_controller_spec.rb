# coding: utf-8

require 'spec_helper'

# This spec was generated by rspec-rails when you ran the scaffold generator.
# It demonstrates how one might use RSpec to specify the controller code that
# was generated by Rails when you ran the scaffold generator.
#
# It assumes that the implementation code is generated by the rails scaffold
# generator.  If you are using any extension libraries to generate different
# controller code, this generated spec may or may not pass.
#
# It only uses APIs available in rails and/or rspec-rails.  There are a number
# of tools you can use to make these specs even more expressive, but we're
# sticking to rails and rspec-rails APIs to keep things simple and stable.
#
# Compared to earlier versions of this generator, there is very limited use of
# stubs and message expectations in this spec.  Stubs are only used when there
# is no simpler way to get a handle on the object needed for the example.
# Message expectations are only used when there is no simpler way to specify
# that an instance is receiving a specific message.

RSpec.configure do |c|
  # c.filter = {wip:true}
end

describe Admin::DestinationsController do
  include SpecControllerHelper

  let(:dest1) {mock_model(Destination) }
     

  def valid_attributes
    {"name"=>'une activité', "used"=>true}
  end

  before(:each) do
    minimal_instances
    @o.stub(:destinations).and_return(@a = double(Arel))
  end

  describe "GET index"  do 


    it "cherche les destinations" do
      @o.should_receive(:destinations).and_return
      get :index, {organism_id:@o.to_param}, valid_session
    end
    
    it 'et l assigne' do
      get :index, {organism_id:@o.to_param}, valid_session
      assigns(:destinations).should == @a
    end
    
  end

  

  describe "GET new"  do 
    before(:each) do
      # permettra de fournir le secteur à la nouvelle destination
      @o.stub(:sectors).and_return([double(Sector, id:7)])
    end
    
    it "construit une nouvelle destionation de l organisme" do
      @a.should_receive(:new).and_return(@mock_dest = Destination.new)
      get :new,  {:organism_id=>@o.to_param}, valid_session
      # assigns.should == []
      assigns(:destination).should == @mock_dest
    end
    
    it 'la destination est active par défaut' do
      @a.stub(:new).and_return(@mock_dest = Destination.new)
      get :new,  {:organism_id=>@o.to_param}, valid_session
      @mock_dest.used.should == true 
    end
    
    it 'le secteur est assigné' do
      @a.stub(:new).and_return(@mock_dest = Destination.new)
      get :new,  {:organism_id=>@o.to_param}, valid_session
      @mock_dest.sector_id.should == 7  
    end
  end

  describe "GET edit"  do
    it "cherche la destination et l'assigne" do
      @o.should_receive(:destinations).and_return(@ar = double(Arel))
      @ar.should_receive(:find).with('7').and_return(@d2 = double(Destination))
      get :edit,  {:organism_id=>@o.to_param, id:7}, valid_session
      assigns(:destination).should == @d2
    end
  end

  describe "POST create"  do
    describe "with valid params" do
      it "creates a new destination" do
          @o.should_receive(:destinations).and_return(@ar = double(Arel))
          @ar.should_receive(:new).with(valid_attributes).
            and_return(dest1 = mock_model(Destination).as_new_record)
          dest1.stub(:save).and_return true
          post :create, {:organism_id=>@o.to_param, :destination => valid_attributes}, valid_session
      end

      it "assigns a newly created destination as @destination" do
        @o.stub(:destinations).and_return(@ar = double(Arel))
          @ar.stub(:new).with(valid_attributes).
            and_return(dest1 = mock_model(Destination).as_new_record)
        dest1.stub(:save).and_return(true)
        post :create, {:organism_id=>@o.to_param, :destination => valid_attributes}, valid_session
        assigns(:destination).should == dest1
        
      end

      it "redirects to the index action" do
        @o.stub(:destinations).and_return(@ar = double(Arel))
          @ar.stub(:new).with(valid_attributes).
            and_return(dest1 = mock_model(Destination).as_new_record)
        dest1.stub(:save).and_return(true)
        post :create, {:organism_id=>@o.to_param, :destination => valid_attributes}, valid_session
        response.should redirect_to(admin_organism_destinations_url(@o))
      end 
    end

    describe "with invalid params" do
      
      it "re-renders the 'new' template" do
        @a.stub(:new).and_return(dest1)
        dest1.stub(:save).and_return(false)
        post :create, {:organism_id=>@o.to_param, :destination => valid_attributes}, valid_session
        response.should render_template("new")
      end
    end
  end

  describe "PUT update" do
    describe "with valid params" do
      it "updates the requested destination" do
        @a.should_receive(:find).with(dest1.to_param).and_return(dest1)
        dest1.should_receive(:update_attributes).with({'comment' => 'params'}).and_return(true)
        put :update,{:organism_id=>@o.to_param, :id => dest1.to_param,
          :destination => {'comment' => 'params'}}, valid_session
      end

      it "assigns the requested destination as @destination" do
        @a.stub(:find).with(dest1.to_param).and_return(dest1)
        dest1.stub(:update_attributes).and_return(true)
        put :update,{:organism_id=>@o.to_param, :id => dest1.to_param,
          :destination => {'comment' => 'params'}}, valid_session
        assigns(:destination).should == dest1
      end

      it "and redirects to the natures index" do
        @a.stub(:find).with(dest1.to_param).and_return(dest1)
        dest1.stub(:update_attributes).and_return(true)
        put :update,{:organism_id=>@o.to_param, :id => dest1.to_param,
          :destination => {'comment' => 'params'}}, valid_session
        response.should redirect_to(admin_organism_destinations_url(@o))
      end
    end

    describe "with invalid params" do
      it "assigns the bank_account as @bank_account" do
        @a.stub(:find).with(dest1.to_param).and_return(dest1)
        dest1.stub(:update_attributes).and_return(false)
        put :update,{:organism_id=>@o.to_param, :id => dest1.to_param,
          :destination => {'comment' => 'params'}}, valid_session
        assigns(:destination).should eq(dest1)
      end

      it "re-renders the 'edit' template" do
       @a.stub(:find).with(dest1.to_param).and_return(dest1)
        dest1.stub(:update_attributes).and_return(false)
        put :update,{:organism_id=>@o.to_param, :id => dest1.to_param,
          :destination => {'comment' => 'params'}}, valid_session
        response.should render_template("edit")
      end
    end
  end

  describe "DELETE destroy"  do
    it "destroys the requested destination" do
       @a.should_receive(:find).with(dest1.to_param).and_return(dest1)
       dest1.should_receive(:destroy).and_return true
        delete :destroy, {:organism_id=>@o.to_param,  :id => dest1.to_param}, valid_session

    end

    it "redirects to the destinations list" do
     @a.stub(:find).with(dest1.to_param).and_return(dest1)
         delete :destroy, {:organism_id=>@o.to_param,  :id => dest1.to_param}, valid_session
      response.should redirect_to(admin_organism_destinations_url(@o))
    end
  end
  
  describe 'toggle_used permet de changer le champ used' do
    
    it 'cherche la destination, toggle used et l assigne' do
      @a.should_receive(:find).with(dest1.to_param).and_return(dest1)
      dest1.stub(:toggle).with(:used).and_return dest1
      dest1.stub(:save).and_return true
      post :toggle_used, {:organism_id=>@o.to_param,  :id => dest1.to_param, format: :js}, valid_session
      assigns(:destination).should == dest1
    end
    
    it 'si ne la trouve pas crée un flash alert' do
      @a.stub(:find).with(dest1.to_param).and_return(nil)
      post :toggle_used, {:organism_id=>@o.to_param,  :id => dest1.to_param, format: :js}, valid_session
      flash[:alert].should == 'Impossible de trouver l\'activité demandée'
    end
    
    
  end

  
  

  
end
